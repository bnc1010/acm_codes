
#include<stdio.h>
#include<algorithm>
#include<map> 
using namespace std;
#define N 100005
int root[N];
int size[N*25],lchild[N*25],rchild[N*25];
int tot;
void insert(int last,int cur,int L,int R,int k) //单点更新 
{
    size[cur]=size[last]+1;//将前一个树的信息复制过来 
    lchild[cur]=lchild[last];
    rchild[cur]=rchild[last]; 
    if(L==R)return ;
    int mid=L+R>>1;
    if(k<=mid) insert(lchild[last],lchild[cur]=++tot,L,mid,k);//对于需要更改的节点都需要新增节点
    else insert(rchild[last],rchild[cur]=++tot,mid+1,R,k);
}
int query(int last,int cur,int k,int L,int R)
{
    if(L==R)return L;
    int mid=L+R>>1;
    int lsum=size[lchild[cur]]-size[lchild[last]];
    if(lsum>=k)return query(lchild[last],lchild[cur],k,L,mid);
    else return query(rchild[last],rchild[cur],k-lsum,mid+1,R);
}
int a[N],b[N],n,m,l,r,k;
map<int,int>mp;
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        tot=0;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
        	scanf("%d",&a[i]),b[i]=a[i];
        sort(b+1,b+n+1);
        int t=unique(b+1,b+n+1)-b-1;
        for(int i=1;i<=n;i++)insert(root[i-1],root[i]=++tot,1,t,lower_bound(b+1,b+t+1,a[i])-b);
        for(int i=0;i<m;i++)
        {
            scanf("%d%d%d",&l,&r,&k);
            printf("%d\n",b[query(root[l-1],root[r],k,1,t)]);
        }
    }
}