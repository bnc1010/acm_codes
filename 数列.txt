#include <bits/stdc++.h>
#define rep(i,a,b) for(ll i=a;i<=b;i++)
using namespace std;
typedef long long ll;
const ll N=55;
const ll mo=1e9+7;
ll fpow(ll a,ll b){
    ll ans=1;
    while(b>0){if(b&1)ans=ans*a%mo;b>>=1;a=a*a%mo;}
    return ans;
}
vector<ll> BM(const vector<ll> &s){
    vector<ll> C={1},B={1},T;
    ll L=0,m=1,b=1;
    rep(n,0,s.size()-1){
        ll d=0;
        rep(i,0,L)d=(d+s[n-i]%mo*C[i])%mo;
        if(d==0)m++;
        else{
            T=C;
            ll t=mo-fpow(b,mo-2)*d%mo;
            while(C.size()<B.size()+m)C.push_back(0);
            rep(i,0,B.size()-1)C[i+m]=(C[i+m]+t*B[i])%mo;
            if(2*L>n)m++;
            else L=n+1-L,B=T,b=d,m=1;
        }
    }
    return C;
}
ll MatrixSolve(const vector<ll> &s,const vector<ll> &C,ll n){
    if(n<s.size())return s[n];
    ll k=C.size()-1,b=n-k+1;
    static ll B[N][N],t[N],a[N],c[N][N];
    rep(i,0,k-1)a[i]=s[i];
    rep(i,0,k-1)rep(j,0,k-1)B[i][j]=j==0?((C[i+1]>0)*mo-C[i+1]):(i==j-1);
    while(b){
        if(b&1){
            rep(i,0,k-1)t[i]=0;
            rep(i,0,k-1)rep(j,0,k-1)t[i]=(t[i]+a[k-j-1]*B[j][k-i-1])%mo;
            rep(i,0,k-1)a[i]=t[i];
        }
        b>>=1;
        rep(i,0,k-1)rep(j,0,k-1)c[i][j]=0;
        rep(r,0,k-1)rep(j,0,k-1)if(B[r][j])rep(i,0,k-1)c[i][j]=(c[i][j]+B[i][r]*B[r][j])%mo;
        rep(i,0,k-1)rep(j,0,k-1)B[i][j]=c[i][j];
    }
    return a[k-1];
}
ll fastMatrixSolve(const vector<ll> &s,const vector<ll> &C,ll n){
    if(n<s.size())return s[n];
    ll k=C.size()-1,b=n-k+1;
    static ll B[N][N][64],t[N],a[N],c[N][N],init_flag=1;
    if(init_flag){
        init_flag=0;
        rep(i,0,k-1)rep(j,0,k-1)B[i][j][0]=j==0?((C[i+1]>0)*mo-C[i+1]):(i==j-1);
        for(ll it=1;it<64;it++){
            rep(i,0,k-1)rep(j,0,k-1)B[i][j][it]=0;
            rep(r,0,k-1)rep(j,0,k-1)if(B[r][j][it-1])rep(i,0,k-1)B[i][j][it]=(B[i][j][it]+B[i][r][it-1]*B[r][j][it-1])%mo;
        }
    }
    rep(i,0,k-1)a[i]=s[i];
    ll it=0;
    while(b){
        if(b&1){
            rep(i,0,k-1)t[i]=0;
            rep(i,0,k-1)rep(j,0,k-1)t[i]=(t[i]+a[k-j-1]*B[j][k-i-1][it])%mo;
            rep(i,0,k-1)a[i]=t[i];
        }
        b>>=1;
        it++;
    }
    return a[k-1];
}
class NewtonPoly{
public:
    ll f[N],d[N],x[N],n=0;
    void add(ll X,ll Y){
        x[n]=X,f[n]=Y%mo;
        rep(i,1,n)f[n-i]=(f[n-i+1]-f[n-i])%mo*fpow((x[n]-x[n-i])%mo,mo-2)%mo;
        d[n++]=f[0];
    }
    ll operator () (ll X)const{
        ll ans=0,t=1;
        rep(i,0,n-1)ans=(ans+d[i]*t)%mo,t=(X-x[i])%mo*t%mo;
        return ans+mo*(ans<0);
    }
};
bool polyCheck(const vector<ll> &C){
    ll m=mo-C[1],last=1;
    rep(i,1,C.size()-1){
        last=last*(m-i+1)%mo*fpow(i,mo-2)%mo;
        if(last!=(i&1?(mo-C[i]):C[i]))return false;
    }
    return true;
}
class Sequence{
public:
    ll poly;
    vector<ll> A,C;
    NewtonPoly P;
    void build(const vector<ll> &s){
        A=s;
        C=BM(A);
        poly=polyCheck(C);
        if(poly)rep(i,0,s.size()-1)P.add(i,s[i]);
    }
    ll operator () (ll n)const{
        return poly?P(n):fastMatrixSolve(A,C,n);
    }
    friend ostream &operator << (ostream &o,const Sequence &b){
        o<<"f(n)";
        rep(i,1,b.C.size()-1)o<<"+("<<b.C[i]<<")*f(n-"<<i<<")";
        o<<"=0 (mod "<<mo<<")";
        return o;
    }
}F;

int main(){
    ios::sync_with_stdio(false);
    F.build({1,5,17,49,129,321,769,1793,4097,9217});
    cout<<F<<endl;
    ll n;
    while(cin>>n){
        cout<<F(n-1)<<endl;
    }
    return 0;
}
