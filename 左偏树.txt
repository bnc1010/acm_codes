/*
*1 x y 将第x个数和第y个数所在的小根堆合并
*（若第x或第y个数已经被删除或第x和第y个数在用一个堆内，则无视此操作）
*2 x 输出第x个数所在的堆最小数，并将其删除
*（若第x个数已经被删除，则输出-1并无视删除操作）
*/
#include<bits/stdc++.h>
#define up(i,a,b) for (register int i=a;i<=b;++i)
#define down(i,a,b) for (register int i=a;i>=b;--i)
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
inline int read()
{
	int f=1,num=0;
	char ch=getchar();
	while (!isdigit(ch)) { if (ch=='-') f=-1; ch=getchar(); }
	while (isdigit(ch)) num=(num<<1)+(num<<3)+(ch^48), ch=getchar();
	return num*f;
}
int val[maxn],dist[maxn],fa[maxn],ch[maxn][2];
inline int get(int x)//不用路径压缩，不赋初值，所以他祖先没有父亲（为0）
{
	while (fa[x])
		x=fa[x];//一直找，直到这个节点没父亲即为祖先
	return x;
}
inline int merge(int x,int y)//返回值为编号，是直接父亲的编号
{
	if (!x || !y)
		return x+y;
	if (val[x]>val[y] || (val[x]==val[y]&&x>y))
		swap(x,y);
	ch[x][1]=merge(ch[x][1],y);
	fa[ch[x][1]]=x;
	if (dist[ch[x][0]]<dist[ch[x][1]])
		swap(ch[x][1],ch[x][0]);//维持左偏性质
	dist[x]=dist[ch[x][1]]+1;
	//因为是左偏树，所以右边的深度要小，左边深度要大，所以维护距离时,以右儿子为标准统计深度
	return x;
}
inline void delet(int x)
{
	val[x]=-1;
	fa[ch[x][0]]=fa[ch[x][1]]=0;
	merge(ch[x][0],ch[x][1]);
}
int main()
{
	int n=read(),m=read();
	dist[0]=-1;
	up(i,1,n)
		val[i]=read();
	up(i,1,m)
	{
		int t=read();
		if (t==1)
		{
			int x=read(),y=read();
			if (val[x]==-1 || val[y]==-1) continue;//有一个节点被删除
			int fx=get(x),fy=get(y);
			if (fx==fy) continue;//本来就在一个堆里
			merge(fx,fy);
		}
		else
		{
			int x=read();
			if (val[x]==-1) puts("-1");
			else
			{
				int fx=get(x);
				printf("%d\n",val[fx]);
				delet(fx);
			}
		}
	}
	return 0;
}




指针版：
#include <cstdio>
#include <algorithm>

const int maxn=100000;

int read()
{
  int x=0,f=1;
  char ch=getchar();
  while((ch<'0')||(ch>'9'))
    {
      if(ch=='-')
        {
          f=-f;
        }
      ch=getchar();
    }
  while((ch>='0')&&(ch<='9'))
    {
      x=x*10+ch-'0';
      ch=getchar();
    }
  return x*f;
}

struct node
{
  node* son[2];
  node* fa;
  int val,dist,pos;
};

node tnode[maxn+10];
node* p[maxn+10];
int n,m;

inline int upd_dist(node* now)
{
  if(now->son[1]!=NULL)
    {
      now->dist=now->son[1]->dist+1;
    }
  else
    {
      now->dist=0;
    }
  return 0;
}

node* merge(node* a,node* b)
{
  if(a==NULL)
    {
      return b;
    }
  if(b==NULL)
    {
      return a;
    }
  if((a->val>b->val)||((a->val==b->val)&&(a->pos>b->pos)))
    {
      std::swap(a,b);
    }
  a->son[1]=merge(a->son[1],b);
  a->son[1]->fa=a;
  if((a->son[0]!=NULL)&&(a->son[1]!=NULL)&&(a->son[0]->dist<a->son[1]->dist))
    {
      std::swap(a->son[0],a->son[1]);
    }
  else if((a->son[0]==NULL)&&(a->son[1]!=NULL))
    {
      a->son[0]=a->son[1];
      a->son[1]=NULL;
    }
  upd_dist(a);
  return a;
}

node* getf(node* x)
{
  if(x->fa==NULL)
    {
      return x;
    }
  return getf(x->fa);
}

int getmin_pop(node* x)
{
  node* f=getf(x);
  int v=f->val;
  node* s=merge(f->son[0],f->son[1]);
  if(s!=NULL)
    {
      s->fa=NULL;
    }
  f->pos=-1;
  return v;
}

int main()
{
  n=read();
  m=read();
  for(int i=1; i<=n; ++i)
    {
      p[i]=&tnode[i];
      p[i]->son[0]=p[i]->son[1]=p[i]->fa=NULL;
      p[i]->val=read();
      p[i]->dist=0;
      p[i]->pos=i;
    }
  while(m--)
    {
      int op=read(),a=read();
      if(op==1)
        {
          int b=read();
          if((p[a]->pos==-1)||(p[b]->pos==-1))
            {
              continue;
            }
          node* fa=getf(p[a]);
          node* fb=getf(p[b]);
          if(fa==fb)
            {
              continue;
            }
          merge(fa,fb);
        }
      else
        {
          if(p[a]->pos==-1)
            {
              puts("-1");
            }
          else
            {
              printf("%d\n",getmin_pop(p[a]));
            }
        }
    }
  return 0;
}
