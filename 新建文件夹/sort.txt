STL 中 sort 函数用法简介
    做 ACM 题的时候，排序是一种经常要用到的操作。如果每次都自己写个冒泡之类的 O(n^2) 排序，不但程序容易超时，而且浪费宝贵的比赛时间，还很有可能写错。 STL 里面有个 sort 函数，可以直接对数组排序，复杂度为 n*log2(n) 。使用这个函数，需要包含头文件。
    这个函数可以传两个参数或三个参数。第一个参数是要排序的区间首地址，第二个参数是区间尾地址的下一地址。也就是说，排序的区间是 [a,b) 。简单来说，有一个数组 int a[100] ，要对从 a[0] 到 a[99] 的元素进行排序，只要写 sort(a,a+100) 就行了，默认的排序方式是升序。
    拿我出的“ AC 的策略”这题来说，需要对数组 t 的第 0 到 len-1 的元素排序，就写 sort(t,t+len);
    对向量 v 排序也差不多， sort(v.begin(),v.end());
    排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类 string 。
    如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数――比较函数。比较函数是一个自己定义的函数，返回值是 bool 型，它规定了什么样的关系才是“小于”。想把刚才的整数数组按降序排列，可以先定义一个比较函数 cmp
bool cmp(int a,int b)
{
    return a>b;
}
   排序的时候就写 sort(a,a+100,cmp);
   假设自己定义了一个结构体 node
struct node{
    int a;
    int b;
    double c;
}
   有一个 node 类型的数组 node arr[100] ，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写这样一个比较函数：
以下是代码片段：
bool cmp(node x,node y)
{
if(x.a!=y.a) return x.a
if(x.b!=y.b) return x.b>y.b;
return return x.c>y.c;
}
    排序时写 sort(arr,a+100,cmp);
    最后看一个完整的实例，初赛时的一道题目“文件名排序 ”。
以下是代码片段：
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
// 定义一个结构体来表示文件， a 代表文件名， b 代表文件类型（要么 "File" 要么 "Dir" ）
struct node{
string a,b;
};
//ASCII 码中，所有大写字母排在所有小写字母前面， 'A'<'Z'<'a'<'z'
// 而这题要求忽略大小写，所以不能直接用字符串的比较。自定义了一个 lt 函数，就是 less than 的意思
// 先把两个字符串全部转化为小写，再比较大小（字典序）
bool lt(string x,string y)
{
int i;
for(i=0;i<x.length();i++)
if(x[i]>='A'&&x[i]<='Z')
   x[i]='a'+(x[i]-'A');
for(i=0;i<y.length();i++)
if(y[i]>='A'&&y[i]<='Z')
   y[i]='a'+(y[i]-'A');
return x<y;
}
// 自定义的比较函数，先按 b 值升序排列（也就是 "Dir" 排在 "File" 前面）
// 如果 b 值相同，再按 a 升序排列，用的是刚才定义的 lt 函数
bool comp(node x,node y)
{
if(x.b!=y.b)return x.b<y.b;
return lt(x.a,y.a);
}
int main()
{
node arr[10001];
int size=0;
while(cin>>arr[size].a>>arr[size].b)
size++;
sort(arr,arr+size,comp);
for(int i=0;i<size;i++)
cout<<arr[i].a<<" "<<arr[i].b<<endl;
return 0;
}
 
 
七种 qsort 排序方法     
< 本文中排序都是采用的从小到大排序 >    
一、对 int 类型数组排序     
int   num[100];    
Sample:    
int   cmp   (   const   void   *a   ,   const   void   *b   )    
{    
return   *(int   *)a   -   *(int   *)b;    
}    
qsort(num,100,sizeof(num[0]),cmp);    
二、对 char 类型数组排序（同 int 类型）     
char   word[100];    
Sample:    
int   cmp(   const   void   *a   ,   const   void   *b   )    
{    
return   *(char   *)a   -   *(char   *)b;    
}    
qsort(word,100,sizeof(word[0]),cmp);    
三、对 double 类型数组排序（特别要注意）     
double   in[100];    
int   cmp(   const   void   *a   ,   const   void   *b   )    
{    
return   *(double   *)a   >   *(double   *)b   ?   1   :   -1;    
}    
qsort(in,100,sizeof(in[0]),cmp) ；     
四、对结构体一级排序     
struct   In    
{    
double   data;    
int   other;    
}s[100]    
// 按照 data 的值从小到大将结构体排序 , 关于结构体内的排序关键数据 data 的类型可以很多种，参考上面的例子写     
int   cmp(   const   void   *a   ,const   void   *B)    
{   
return   (*(In   *)a)->data   >   (*(In   *)B)->data   ?   1   :   -1;    
}    
qsort(s,100,sizeof(s[0]),cmp);    
五、对结构体二级排序     
struct   In    
{    
int   x;    
int   y;    
}s[100];    
// 按照 x 从小到大排序，当 x 相等时按照 y 从大到小排序     
int   cmp(   const   void   *a   ,   const   void   *b   )    
{    
struct   In   *c   =   (In   *)a;    
struct   In   *d   =   (In   *)b;    
if(c->x   !=   d->x)   return   c->x   -   d->x;    
else   return   d->y   -   c->y;    
}     
qsort(s,100,sizeof(s[0]),cmp);    
六、对字符串进行排序     
struct   In    
{    
int   data;    
char   str[100];    
}s[100];    
// 按照结构体中字符串 str 的字典顺序排序     
int   cmp   (   const   void   *a   ,   const   void   *b   )    
{    
return   strcmp(   (*(In   *)a)->str   ,   (*(In   *)B)->str   );    
}    
qsort(s,100,sizeof(s[0]),cmp);    
七、计算几何中求凸包的 cmp    
int   cmp(const   void   *a,const   void   *B)   // 重点 cmp 函数，把除了 1 点外的所有点，旋转角度排序     
{    
struct   point   *c=(point   *)a;    
struct   point   *d=(point   *)b;    
if(   calc(*c,*d,p[1])   <   0)   return   1;    
else   if(   !calc(*c,*d,p[1])   &&   dis(c->x,c->y,p[1].x,p[1].y)   <   dis(d->x,d->y,p[1].x,p[1].y))   // 如果在一条直线上，则把远的放在前面     
return   1;    
else   return   -1;    
}