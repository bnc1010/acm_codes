<返回类型说明符> operator <运算符符号>(<参数表>)  
{  
  
     <函数体>  
  
}  

struct tt
{
	int a;
	int b;
	bool operator < (const tt &x)const
	{
		if(a==x.a) return  b<x.b;
		return  a<x.a;
        }
};

运算符重载的规则：
（1）为了防止用户对标准类型进行运算符重载，C++规定重载后的运算符的操作对象必须至少有一个是用户定义的类型
这是什么意思呢？
比如说现在有两个数：int number1,int number2，
那么number1+number2 求的是两个数的和，
但是如果你重载以后让着两个数相加为他们的乘积，这肯定是不合乎逻辑的。
可能重载以后会有二义性,导致程序不知道该执行哪一个（是自带的的还是重载后的函数）

（2）使用运算符不能违法运算符原来的句法规则。如不能将% 重载为一个操作数，
例如：
int index；
%index；这种是不被允许的。

（3）不能修改运算符原先的优先级。

（4）不能创建一个新的运算符，例如不能定义operator** （・・・）来表示求幂

（5）不能进行重载的运算符：成员运算符，作用域运算符，条件运算符，sizeof运算符，typeid（一个RTTI运算符），const_cast、dynamic_cast、reinterpret_cast、static_cast强制类型转换运算符

（6）大多数运算符可以通过成员函数和非成员函数进行重载但是下面这四种运算符只能通过成函数进行重载：
= 赋值运算符，（）函数调用运算符，[ ]下标运算符，->通过指针访问类成员的运算符。

（7）除了上述的规则，其实我们还应该注意在重载运算符的时候遵守一些明智的规则：例如：不要将+运算符重载为交换两个对象的值。